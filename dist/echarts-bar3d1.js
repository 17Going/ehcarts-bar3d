(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("echarts"));
	else if(typeof define === 'function' && define.amd)
		define(["echarts"], factory);
	else if(typeof exports === 'object')
		exports["echarts-bar3d"] = factory(require("echarts"));
	else
		root["echarts-bar3d"] = factory(root["echarts"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/bar3d */ \"./src/bar3d.js\");\r\n\n\n//# sourceURL=webpack://echarts-bar3d/./index.js?");

/***/ }),

/***/ "./node_modules/echarts/lib/layout/barGrid.js":
/*!****************************************************!*\
  !*** ./node_modules/echarts/lib/layout/barGrid.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/echarts/node_modules/zrender/lib/core/util.js\");\n\nvar _number = __webpack_require__(/*! ../util/number */ \"./node_modules/echarts/lib/util/number.js\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n//# sourceURL=webpack://echarts-bar3d/./node_modules/echarts/lib/layout/barGrid.js?");

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/makeStyleMapper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/model/mixin/makeStyleMapper.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/echarts/node_modules/zrender/lib/core/util.js\");\n\n// TODO Parse shadow style\n// TODO Only shallow path support\nfunction _default(properties) {\n  // Normalize\n  for (var i = 0; i < properties.length; i++) {\n    if (!properties[i][1]) {\n      properties[i][1] = properties[i][0];\n    }\n  }\n\n  return function (model, excludes, includes) {\n    var style = {};\n\n    for (var i = 0; i < properties.length; i++) {\n      var propName = properties[i][1];\n\n      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {\n        continue;\n      }\n\n      var val = model.getShallow(propName);\n\n      if (val != null) {\n        style[properties[i][0]] = val;\n      }\n    }\n\n    return style;\n  };\n}\n\nmodule.exports = _default;\n\n//# sourceURL=webpack://echarts-bar3d/./node_modules/echarts/lib/model/mixin/makeStyleMapper.js?");

/***/ }),

/***/ "./node_modules/echarts/lib/util/number.js":
/*!*************************************************!*\
  !*** ./node_modules/echarts/lib/util/number.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/echarts/node_modules/zrender/lib/core/util.js\");\n\nvar RADIAN_EPSILON = 1e-4;\n\nfunction _trim(str) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n/**\n * Linear mapping a value from domain to range\n * @memberOf module:echarts/util/number\n * @param  {(number|Array.<number>)} val\n * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n * @param  {boolean} clamp\n * @return {(number|Array.<number>}\n */\n\n\nfunction linearMap(val, domain, range, clamp) {\n  var subDomain = domain[1] - domain[0];\n  var subRange = range[1] - range[0];\n\n  if (subDomain === 0) {\n    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n  } // Avoid accuracy problem in edge, such as\n  // 146.39 - 62.83 === 83.55999999999999.\n  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n  // It is a little verbose for efficiency considering this method\n  // is a hotspot.\n\n\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= domain[0]) {\n        return range[0];\n      } else if (val >= domain[1]) {\n        return range[1];\n      }\n    } else {\n      if (val >= domain[0]) {\n        return range[0];\n      } else if (val <= domain[1]) {\n        return range[1];\n      }\n    }\n  } else {\n    if (val === domain[0]) {\n      return range[0];\n    }\n\n    if (val === domain[1]) {\n      return range[1];\n    }\n  }\n\n  return (val - domain[0]) / subDomain * subRange + range[0];\n}\n/**\n * Convert a percent string to absolute number.\n * Returns NaN if percent is not a valid string or number\n * @memberOf module:echarts/util/number\n * @param {string|number} percent\n * @param {number} all\n * @return {number}\n */\n\n\nfunction parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n\n  if (typeof percent === 'string') {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n\n    return parseFloat(percent);\n  }\n\n  return percent == null ? NaN : +percent;\n}\n/**\n * (1) Fix rounding error of float numbers.\n * (2) Support return string to avoid scientific notation like '3.5e-7'.\n *\n * @param {number} x\n * @param {number} [precision]\n * @param {boolean} [returnStr]\n * @return {number|string}\n */\n\n\nfunction round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  } // Avoid range error\n\n\n  precision = Math.min(Math.max(0, precision), 20);\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\n\nfunction asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\n/**\n * Get precision\n * @param {number} val\n */\n\n\nfunction getPrecision(val) {\n  val = +val;\n\n  if (isNaN(val)) {\n    return 0;\n  } // It is much faster than methods converting number to string as follows\n  //      var tmp = val.toString();\n  //      return tmp.length - 1 - tmp.indexOf('.');\n  // especially when precision is low\n\n\n  var e = 1;\n  var count = 0;\n\n  while (Math.round(val * e) / e !== val) {\n    e *= 10;\n    count++;\n  }\n\n  return count;\n}\n/**\n * @param {string|number} val\n * @return {number}\n */\n\n\nfunction getPrecisionSafe(val) {\n  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'\n\n  var eIndex = str.indexOf('e');\n\n  if (eIndex > 0) {\n    var precision = +str.slice(eIndex + 1);\n    return precision < 0 ? -precision : 0;\n  } else {\n    var dotIndex = str.indexOf('.');\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n  }\n}\n/**\n * Minimal dicernible data precisioin according to a single pixel.\n *\n * @param {Array.<number>} dataExtent\n * @param {Array.<number>} pixelExtent\n * @return {number} precision\n */\n\n\nfunction getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.\n\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\n/**\n * Get a data of given precision, assuring the sum of percentages\n * in valueList is 1.\n * The largest remainer method is used.\n * https://en.wikipedia.org/wiki/Largest_remainder_method\n *\n * @param {Array.<number>} valueList a list of all data\n * @param {number} idx index of the data to be processed in valueList\n * @param {number} precision integer number showing digits of precision\n * @return {number} percent ranging from 0 to 100\n */\n\n\nfunction getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n\n  var sum = zrUtil.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n\n  if (sum === 0) {\n    return 0;\n  }\n\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrUtil.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrUtil.map(votesPerQuota, function (votes) {\n    // Assign automatic seats.\n    return Math.floor(votes);\n  });\n  var currentSum = zrUtil.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  }); // Has remainding votes.\n\n  while (currentSum < targetSeats) {\n    // Find next largest remainder.\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    } // Add a vote to max remainder.\n\n\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n\n  return seats[idx] / digits;\n} // Number.MAX_SAFE_INTEGER, ie do not support.\n\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * To 0 - 2 * PI, considering negative radian.\n * @param {number} radian\n * @return {number}\n */\n\nfunction remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\n/**\n * @param {type} radian\n * @return {boolean}\n */\n\n\nfunction isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n/**\n * @param {string|Date|number} value These values can be accepted:\n *   + An instance of Date, represent a time in its own time zone.\n *   + Or string in a subset of ISO 8601, only including:\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n *     all of which will be treated as local time if time zone is not specified\n *     (see <https://momentjs.com/>).\n *   + Or other string format, including (all of which will be treated as loacal time):\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n *   + a timestamp, which represent a time in UTC.\n * @return {Date} date\n */\n\nfunction parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (typeof value === 'string') {\n    // Different browsers parse date in different way, so we parse it manually.\n    // Some other issues:\n    // new Date('1970-01-01') is UTC,\n    // new Date('1970/01/01') and new Date('1970-1-01') is local.\n    // See issue #3623\n    var match = TIME_REG.exec(value);\n\n    if (!match) {\n      // return Invalid Date.\n      return new Date(NaN);\n    } // Use local time when no timezone offset specifed.\n\n\n    if (!match[8]) {\n      // match[n] can only be string or undefined.\n      // But take care of '12' + 1 => '121'.\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n    // For example, system timezone is set as \"Time Zone: America/Toronto\",\n    // then these code will get different result:\n    // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n    // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n    // So we should not use `new Date`, but use `Date.UTC`.\n    else {\n        var hour = +match[4] || 0;\n\n        if (match[8].toUpperCase() !== 'Z') {\n          hour -= match[8].slice(0, 3);\n        }\n\n        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n      }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n\n  return new Date(Math.round(value));\n}\n/**\n * Quantity of a number. e.g. 0.1, 1, 10, 100\n *\n * @param  {number} val\n * @return {number}\n */\n\n\nfunction quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\n\nfunction quantityExponent(val) {\n  return Math.floor(Math.log(val) / Math.LN10);\n}\n/**\n * find a “nice” number approximately equal to x. Round the number if round = true,\n * take ceiling if round = false. The primary observation is that the “nicest”\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n *\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n *\n * @param  {number} val Non-negative value.\n * @param  {boolean} round\n * @return {number}\n */\n\n\nfunction nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10; // 1 <= f < 10\n\n  var nf;\n\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n\n  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n  // 20 is the uppper bound of toFixed.\n\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n/**\n * Order intervals asc, and split them when overlap.\n * expect(numberUtil.reformIntervals([\n *     {interval: [18, 62], close: [1, 1]},\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [1, 1]},\n *     {interval: [62, 150], close: [1, 1]},\n *     {interval: [106, 150], close: [1, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ])).toEqual([\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [0, 1]},\n *     {interval: [18, 62], close: [0, 1]},\n *     {interval: [62, 150], close: [0, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ]);\n * @param {Array.<Object>} list, where `close` mean open or close\n *        of the interval, and Infinity can be used.\n * @return {Array.<Object>} The origin list, which has been reformed.\n */\n\n\nfunction reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close = list[i].close;\n\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close[lg] = !lg ? 1 - currClose : 1;\n      }\n\n      curr = interval[lg];\n      currClose = close[lg];\n    }\n\n    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  return list;\n\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\n/**\n * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n * subtraction forces infinities to NaN\n *\n * @param {*} v\n * @return {boolean}\n */\n\n\nfunction isNumeric(v) {\n  return v - parseFloat(v) >= 0;\n}\n\nexports.linearMap = linearMap;\nexports.parsePercent = parsePercent;\nexports.round = round;\nexports.asc = asc;\nexports.getPrecision = getPrecision;\nexports.getPrecisionSafe = getPrecisionSafe;\nexports.getPixelPrecision = getPixelPrecision;\nexports.getPercentWithPrecision = getPercentWithPrecision;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nexports.remRadian = remRadian;\nexports.isRadianAroundZero = isRadianAroundZero;\nexports.parseDate = parseDate;\nexports.quantity = quantity;\nexports.nice = nice;\nexports.reformIntervals = reformIntervals;\nexports.isNumeric = isNumeric;\n\n//# sourceURL=webpack://echarts-bar3d/./node_modules/echarts/lib/util/number.js?");

/***/ }),

/***/ "./node_modules/echarts/node_modules/zrender/lib/core/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/node_modules/zrender/lib/core/util.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @module zrender/core/util\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * 查询数组中元素的index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * 构造类继承关系\n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz 源类\n * @param {Function} baseClazz 基类\n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * 数组或对象遍历\n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * 数组映射\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * 数组过滤\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * 数组项查找\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n//# sourceURL=webpack://echarts-bar3d/./node_modules/echarts/node_modules/zrender/lib/core/util.js?");

/***/ }),

/***/ "./src/bar3d.js":
/*!**********************!*\
  !*** ./src/bar3d.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 注意：UE中使用多个版本导致echarts依赖有问题\nvar echarts = __webpack_require__(/*! echarts/lib/echarts */ \"echarts/lib/echarts\");\n__webpack_require__(/*! ./bar3d/Bar3dSeries */ \"./src/bar3d/Bar3dSeries.js\");\n__webpack_require__(/*! ./bar3d/Bar3dView */ \"./src/bar3d/Bar3dView.js\");\n\nvar barLayoutGrid = __webpack_require__(/*! echarts/lib/layout/barGrid */ \"./node_modules/echarts/lib/layout/barGrid.js\");\n\necharts.registerLayout(echarts.util.curry(barLayoutGrid, 'bar3d'));\n\necharts.registerVisual(function (ecModel) {\n    ecModel.eachSeriesByType('bar3d', function (seriesModel) {\n        var data = seriesModel.getData();\n        data.setVisual('legendSymbol', 'roundRect');\n    });\n});\n\n//# sourceURL=webpack://echarts-bar3d/./src/bar3d.js?");

/***/ }),

/***/ "./src/bar3d/Bar3dSeries.js":
/*!**********************************!*\
  !*** ./src/bar3d/Bar3dSeries.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(/*! echarts/lib/echarts */ \"echarts/lib/echarts\");\n\nmodule.exports = echarts.extendSeriesModel({\n\n    type: 'series.bar3d',\n\n    dependencies: ['grid', 'polar'],\n\n    brushSelector: 'rect',\n\n    getInitialData: function (option, ecModel) {\n        return echarts.helper.createList(this);\n    },\n\n    getMarkerPosition: function (value) {\n        var coordSys = this.coordinateSystem;\n        if (coordSys) {\n            // PENDING if clamp ?\n            var pt = coordSys.dataToPoint(value, true);\n            var data = this.getData();\n            var offset = data.getLayout('offset');\n            var size = data.getLayout('size');\n            var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n            pt[offsetIndex] += offset + size / 2;\n            return pt;\n        }\n        return [NaN, NaN];\n    },\n\n    defaultOption: {\n        barType: 'cube', // 柱状图的柱子类型 cube | cylinder\n        zlevel: 0,                  // 一级层叠\n        z: 2,                       // 二级层叠\n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n        barMinHeight: 0,\n\n        itemStyle: {\n            normal: {\n                // color: '各异'\n            },\n            emphasis: {}\n        }\n    }\n});\n\n//# sourceURL=webpack://echarts-bar3d/./src/bar3d/Bar3dSeries.js?");

/***/ }),

/***/ "./src/bar3d/Bar3dView.js":
/*!********************************!*\
  !*** ./src/bar3d/Bar3dView.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(/*! echarts/lib/echarts */ \"echarts/lib/echarts\");\nvar zrUtil = echarts.util;\nvar graphic = echarts.graphic;\nvar helper = __webpack_require__(/*! ./helper */ \"./src/bar3d/helper.js\");\nvar colorTool = echarts.color; \nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\nvar graph = __webpack_require__(/*! ./bar3dLayout */ \"./src/bar3d/bar3dLayout.js\");\n\nzrUtil.extend(echarts.Model.prototype, __webpack_require__(/*! ./barItemStyle */ \"./src/bar3d/barItemStyle.js\"));\n\nvar BarView = echarts.extendChartView({\n\n    type: 'bar3d',\n\n    render: function (seriesModel, ecModel, api) {\n        var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n        if (coordinateSystemType === 'cartesian2d') {\n            this._renderOnCartesian(seriesModel, ecModel, api);\n        }\n\n        return this.group;\n    },\n\n    _renderOnCartesian: function (seriesModel, ecModel, api) {\n        var group = this.group;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n        var isHorizontal = baseAxis.isHorizontal();\n        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n        var isCube = (seriesModel.get('barType') == 'cube'); // 获取柱状图柱子类型\n\n        data.diff(oldData)\n            .add(function (dataIndex) {\n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n\n                var itemModel = data.getItemModel(dataIndex);\n                var layout = getRectItemLayout(data, dataIndex, itemModel);\n                var el = isCube ?\n                    createCube(data, dataIndex, itemModel, layout, isHorizontal, animationModel) :\n                    createCylinder(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n\n                data.setItemGraphicEl(dataIndex, el);\n                group.add(el);\n\n                isCube ? updateCubeStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) :\n                    updateCylinderStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n            })\n            .update(function (newIndex, oldIndex) {\n                var el = oldData.getItemGraphicEl(oldIndex);\n\n                if (!data.hasValue(newIndex)) {\n                    group.remove(el);\n                    return;\n                }\n\n                var itemModel = data.getItemModel(newIndex);\n                var layout = getRectItemLayout(data, newIndex, itemModel);\n\n                if (el) {\n                    isCube ? updateCube(el, layout, isHorizontal, animationModel, newIndex) :\n                        updateCylinder(el, layout, isHorizontal, animationModel, newIndex);\n                }\n                else {\n                    el = barType == 'cube' ?\n                        createCube(data, newIndex, itemModel, layout, isHorizontal, animationModel, true) :\n                        createCylinder(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n                }\n\n                data.setItemGraphicEl(newIndex, el);\n                group.add(el);\n\n                isCube ? updateCubeStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal) :\n                    updateCylinderStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n            })\n            .remove(function (dataIndex) {\n                var el = oldData.getItemGraphicEl(dataIndex);\n                el && removeRect(dataIndex, animationModel, el);\n            })\n            .execute();\n\n        this._data = data;\n    },\n\n    remove: function (ecModel, api) {\n        var group = this.group;\n        var data = this._data;\n        if (ecModel.get('animation')) {\n            if (data) {\n                data.eachItemGraphicEl(function (el) {\n                    removeRect(el.dataIndex, ecModel, el);\n                });\n            }\n        }\n        else {\n            group.removeAll();\n        }\n    },\n\n    dispose: function () { }\n});\n\n\n/**\n * 放大缩小时，更新立方体图形\n * @param {Group} el \n * @param {Object} layout \n * @param {Boolean} isHorizontal\n * @param {Object} animationModel \n * @param {Number} newIndex \n */\nfunction updateCube(el, layout, isHorizontal, animationModel, newIndex) {\n    var shape = zrUtil.extend({}, layout);\n    var points = getPoints(shape, isHorizontal);\n\n    el.eachChild(function (childEl) {\n        if (childEl.location == 'top') {\n            graphic.updateProps(childEl, { shape: getTopShape(shape, points, isHorizontal) }, animationModel, newIndex);\n        } else if (childEl.location == 'bottom') {\n            graphic.updateProps(childEl, { shape: getBottomShape(shape, points, isHorizontal) }, animationModel, newIndex);\n        } else if (childEl.location == 'flank') {\n            graphic.updateProps(childEl, { shape: getFlankShape(shape, points, isHorizontal) }, animationModel, newIndex);\n        } else {\n            graphic.updateProps(childEl, { shape: getFrontShape(shape, points, isHorizontal) }, animationModel, newIndex);\n        }\n    });\n}\n\n/**\n * 放大缩小时，更新圆柱体图形\n * @param {Group} el \n * @param {Object} layout \n * @param {Boolean} isHorizontal\n * @param {Object} animationModel \n * @param {Number} newIndex \n */\nfunction updateCylinder(el, layout, isHorizontal, animationModel, newIndex) {\n    var shape = zrUtil.extend({}, layout);\n\n    el.eachChild(function (childEl) {\n        if (childEl.location == 'top') {\n            graphic.updateProps(childEl, { shape: getCylinderTop(shape, isHorizontal) }, animationModel, newIndex);\n        } else if (childEl.location == 'bottom') {\n            graphic.updateProps(childEl, { shape: getCylinderBottom(shape, isHorizontal) }, animationModel, newIndex);\n        } else {\n            graphic.updateProps(childEl, { shape: getCylinderFront(shape, isHorizontal) }, animationModel, newIndex);\n        }\n    });\n}\n\n/**\n * 绘制立方体\n * @param {null} data \n * @param {Number} dataIndex \n * @param {Object} itemModel \n * @param {Object} layout \n * @param {boolean} isHorizontal \n * @param {Obj } animationModel \n * @param {boolean} isUpdate \n */\nfunction createCube(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var g = new graphic.Group();\n    g.isCube = true; // 设置是否立方体\n\n    var shape = zrUtil.extend({}, layout);\n    var points = getPoints(shape, isHorizontal);\n\n    var bottom = new graph.Quadrangle({\n        location: 'bottom',\n        shape: getBottomShape(shape, points, isHorizontal)\n    });\n\n    // 创建顶面\n    var top = new graph.Quadrangle({\n        location: 'top',\n        shape: getTopShape(shape, points, isHorizontal)\n    });\n\n    var front = new graph.Quadrangle({\n        location: 'front',\n        isHorizontal: isHorizontal,\n        shape: getFrontShape(shape, points, isHorizontal)\n    });\n\n    var leftFlank = new graph.Quadrangle({\n        location: 'flank',\n        shape: getFlankShape(shape, points, isHorizontal)\n    });\n\n    var rightFlank = new graph.Quadrangle({\n        location: 'flank',\n        shape: getRightFlankShape(shape, points, isHorizontal)\n    });\n\n    g.add(rightFlank);\n    g.add(bottom);\n    g.add(top);\n    g.add(leftFlank);\n    g.add(front);\n\n    // Animation\n    if (animationModel) {\n        // 顶面动画\n        var topShape = top.shape;\n        var animateProperty = isHorizontal ? 'y' : 'x';\n        var animate2Property = isHorizontal ? 'y1' : 'x1';\n        var animateTarget = {};\n\n        animateTarget[animateProperty] = topShape[animateProperty];\n        animateTarget[animate2Property] = topShape[animate2Property];\n\n        topShape[animateProperty] = bottom.shape[animateProperty];\n        topShape[animate2Property] = bottom.shape[animate2Property];\n\n        graphic[isUpdate ? 'updateProps' : 'initProps'](top, {\n            shape: animateTarget\n        }, animationModel, dataIndex);\n\n        // 正面动画\n        var frontShape = front.shape;\n        var animateProperty = isHorizontal ? 'height' : 'width';\n        var animateTarget = {};\n\n        animateTarget[animateProperty] = frontShape[animateProperty];\n        frontShape[animateProperty] = 0;\n\n        graphic[isUpdate ? 'updateProps' : 'initProps'](front, {\n            shape: animateTarget\n        }, animationModel, dataIndex);\n\n        // 侧面动画\n        var flankShape = leftFlank.shape;\n        var animateProperty = isHorizontal ? 'height' : 'width';\n        var animateTarget = {};\n        animateTarget[animateProperty] = flankShape[animateProperty];\n        flankShape[animateProperty] = 0;\n\n        graphic[isUpdate ? 'updateProps' : 'initProps'](leftFlank, {\n            shape: animateTarget\n        }, animationModel, dataIndex);\n\n        var flankShape = rightFlank.shape;\n        var animateProperty = isHorizontal ? 'height' : 'width';\n        var animateTarget = {};\n        animateTarget[animateProperty] = flankShape[animateProperty];\n        flankShape[animateProperty] = 0;\n\n        graphic[isUpdate ? 'updateProps' : 'initProps'](rightFlank, {\n            shape: animateTarget\n        }, animationModel, dataIndex);\n    }\n\n    return g;\n}\n\n/**\n * 获取图形朝向\n * @param {Object} shape \n * @param {Boolean} isHorizontal \n */\nfunction getAspect(shape, isHorizontal) {\n    var isUp = true;\n\n    if (isHorizontal && shape.height > 0) {\n        isUp = false;\n    } else if (!isHorizontal && shape.width < 0) {\n        isUp = false;\n    }\n\n    return isUp;\n}\n\n/**\n * 获取绘制立方体面的8个点\n * @param {Object} shape \n * @param {Boolean} isHorizontal \n */\nfunction getPoints(shape, isHorizontal) {\n    var angle = Math.PI / 4;\n    // 根据是横轴显示还是竖轴显示来计算x,y取整， 影响绘制图形（不取整）\n    var x = isHorizontal ? Math.floor(shape.x) + 0.5 : shape.x,\n        y = !isHorizontal ? Math.floor(shape.y) + 0.5 : shape.y,\n        width = shape.width,\n        height = shape.height,\n        length = shape.length ? shape.length : (isHorizontal ? width : height);\n\n    var r = length;\n    var cosY = Math.floor(r * Math.cos(angle) / 2) + 0.5;\n    var sinX = Math.floor(r * Math.sin(angle) / 2) + 0.5;\n\n    // isHorizontal ? height = shape.height = (height + cosY/2): width = shape.width = (width - sinX/2);\n    // isHorizontal ? x = x - sinX/2 : y = y + cosY/2;\n\n    // 横着或者竖着点计算不一样\n    return isHorizontal ? [\n        [x, y], // 1\n        [x + width, y], // 2 \n        [x + width + sinX, y - cosY], // 3\n        [x + sinX, y - cosY], // 4\n\n        [x, y + height], // 5 \n        [x + width, y + height], // 6\n        [x + width + sinX, y - cosY + height], // 7\n        [x + sinX, y - cosY + height] // 8\n    ] : [\n            [x, y + height], // 1\n            [x, y], // 2 \n            [x + sinX, y - cosY], // 3\n            [x + sinX, y - cosY + height], // 4\n\n            [x + width, y + height], // 5\n            [x + width, y], // 6\n            [x + sinX + width, y - cosY], // 7\n            [x + sinX + width, y - cosY + height], // 8\n        ];\n}\n\n/**\n * 获取立方体顶面图形参数\n * @param {Object} shape \n * @param {Array} points \n * @param {Boolean} isHorizontal \n */\nfunction getTopShape(shape, points, isHorizontal) {\n\n    // 通过点1，点2，再根据宽，高获取其余2个点，设置宽高方便动画\n    return isHorizontal ? {\n        x: points[4][0],\n        y: points[4][1],\n        x1: points[7][0],\n        y1: points[7][1],\n        width: shape.width,\n        height: 0,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            x: points[5][0],\n            y: points[5][1],\n            x1: points[6][0],\n            y1: points[6][1],\n            width: 0,\n            height: shape.height,\n            sw: shape.width,\n            sh: shape.height\n        };\n}\n\n/**\n * 获取立方体顶面图形参数\n * @param {Object} shape \n * @param {Array} points \n * @param {Boolean} isHorizontal \n */\nfunction getBottomShape(shape, points, isHorizontal) {\n\n    // 通过点1，点2，再根据宽，高获取其余2个点，设置宽高方便动画\n    return isHorizontal ? {\n        x: points[0][0],\n        y: points[0][1],\n        x1: points[3][0],\n        y1: points[3][1],\n        width: shape.width,\n        height: 0,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            x: points[1][0],\n            y: points[1][1],\n            x1: points[2][0],\n            y1: points[2][1],\n            width: 0,\n            height: shape.height,\n            sw: shape.width,\n            sh: shape.height\n        };\n}\n\n/**\n * 获取立方体正面图形参数\n * @param {Object} shape \n * @param {Array} points \n * @param {Boolean} isHorizontal \n */\nfunction getFrontShape(shape, points, isHorizontal) {\n\n    // 通过点1，点2，再根据宽，高获取其余2个点，设置宽高方便动画\n    return isHorizontal ? {\n        x: points[0][0],\n        y: points[0][1],\n        x1: points[1][0],\n        y1: points[1][1],\n        width: 0,\n        height: shape.height,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            x: points[0][0],\n            y: points[0][1],\n            x1: points[1][0],\n            y1: points[1][1],\n            width: shape.width,\n            height: 0,\n            sw: shape.width,\n            sh: shape.height\n        };\n}\n\n/**\n * 获取立方体侧面图形参数\n * @param {Object} shape \n * @param {Array} points \n * @param {Boolean} isHorizontal \n */\nfunction getFlankShape(shape, points, isHorizontal) {\n\n    // 通过点1，点2，再根据宽，高获取其余2个点，设置宽高方便动画\n    return isHorizontal ? {\n        x: points[1][0],\n        y: points[1][1],\n        x1: points[2][0],\n        y1: points[2][1],\n        width: 0,\n        height: shape.height,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            x: points[1][0],\n            y: points[1][1],\n            x1: points[2][0],\n            y1: points[2][1],\n            width: shape.width,\n            height: 0,\n            sw: shape.width,\n            sh: shape.height\n        };\n}\n\n\n/**\n * 获取立方体右侧面图形参数\n * @param {Object} shape \n * @param {Array} points \n * @param {Boolean} isHorizontal \n */\nfunction getRightFlankShape(shape, points, isHorizontal) {\n\n    // 通过点1，点2，再根据宽，高获取其余2个点，设置宽高方便动画\n    return isHorizontal ? {\n        x: points[0][0],\n        y: points[0][1],\n        x1: points[3][0],\n        y1: points[3][1],\n        width: 0,\n        height: shape.height,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            x: points[0][0],\n            y: points[0][1],\n            x1: points[3][0],\n            y1: points[3][1],\n            width: shape.width,\n            height: 0,\n            sw: shape.width,\n            sh: shape.height\n        };\n}\n\n/**\n * 颜色高亮\n * @param {String|Object} color \n * @param {Number| -1~1} level \n */\nfunction leftColor(color, level) {\n    if (typeof color == 'string') {\n        return colorTool.lift(color, level)\n    } else {\n        // 设置的是渐变色,不改变\n        return color;\n    }\n}\n\n/**\n * 颜色变暗\n * @param {String|Object} color \n * @param {Number| -1~1} level  \n */\nfunction lerpColor(color, level) {\n    if (typeof color == 'string') {\n        return colorTool.lerp(level, [color, '#000'])\n    } else {\n        // 设置的是渐变色, 不改变\n        return color;\n    }\n}\n\n/**\n * 设置立方体图形样式\n * @param {Path} el \n * @param {Array} data \n * @param {Number} dataIndex \n * @param {Object} itemModel \n * @param {Object} layout \n * @param {Object} seriesModel \n * @param {Boolean} isHorizontal \n */\nfunction updateCubeStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n    var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n    var color = data.getItemVisual(dataIndex, 'color');\n    var opacity = data.getItemVisual(dataIndex, 'opacity');\n    var itemStyleModel = itemModel.getModel('itemStyle.normal');\n    var oldColor = itemStyleModel.getBarItemStyle();\n\n    var rightFlank = el.childAt(0),\n        bottom = el.childAt(1),\n        top = el.childAt(2),\n        leftFlank = el.childAt(3),\n        front = el.childAt(4);\n\n    front.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n    top.useStyle(zrUtil.defaults(\n        {\n            fill: leftColor(color, -0.4),\n            opacity: opacity\n        },\n        oldColor\n    ));\n    bottom.useStyle(zrUtil.defaults(\n        {\n            fill: leftColor(color, -0.4),\n            opacity: opacity\n        },\n        oldColor\n    ));\n    rightFlank.useStyle(zrUtil.defaults(\n        {\n            fill: lerpColor(color, 0.2),\n            opacity: opacity\n        },\n        oldColor\n    ));\n\n    leftFlank.useStyle(zrUtil.defaults(\n        {\n            fill: lerpColor(color, 0.2),\n            opacity: opacity\n        },\n        oldColor\n    ));\n    front.useStyle(zrUtil.defaults( // 渲染正面\n        {\n            fill: color,\n            opacity: opacity\n        },\n        oldColor\n    ));\n    // 设置标签\n    var labelPositionOutside = isHorizontal\n        ? (layout.height > 0 ? 'bottom' : 'top')\n        : (layout.width > 0 ? 'left' : 'right');\n\n    helper.setLabel(\n        front.style, hoverStyle, itemModel, color,\n        seriesModel, dataIndex, labelPositionOutside\n    );\n\n    // 设置鼠标移上样式\n    helper.setHoverStyle(el, hoverStyle);\n}\n\n/**\n * 计算渐变色\n * @param {String} color \n */\nfunction gradColor(color, isHorizontal) {\n    // 只支持字符串颜色值计算\n    if (typeof color != 'string') {\n        return color;\n    }\n\n    return new graphic.LinearGradient(\n        0, 0, isHorizontal ? 1 : 0, isHorizontal ? 0 : 1,\n        [\n            { offset: 0, color: color },\n            { offset: 0.43, color: colorTool.lerp(0.6, [color, '#000']) },\n            { offset: 0.57, color: colorTool.lerp(0.6, [color, '#000']) },\n            { offset: 1, color: color }\n        ]\n    );\n}\n\n/**\n * 获取轻微的颜色渐变\n * @param {String} color \n * @param {Number| 0~1} level \n * @param {Boolean} isHorizontal \n */\nfunction gradSlapColor(color, level, isHorizontal) {\n    // 只支持字符串颜色值计算\n    if (typeof color != 'string') {\n        return color;\n    }\n\n    return new graphic.LinearGradient(\n        0, 0, isHorizontal ? 0 : 1, isHorizontal ? 1 : 0,\n        [\n            { offset: 0, color: colorTool.lerp(level, [color, '#000']) },\n            { offset: 1, color: color }\n        ]\n    );\n}\n\n/**\n* 设置圆柱体图形样式\n* @param {Path} el \n* @param {Array} data \n* @param {Number} dataIndex \n* @param {Object} itemModel \n* @param {Object} layout \n* @param {Object} seriesModel \n* @param {Boolean} isHorizontal \n*/\nfunction updateCylinderStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n\n    var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n    var color = data.getItemVisual(dataIndex, 'color');\n    var opacity = data.getItemVisual(dataIndex, 'opacity') || 1;\n    var itemStyleModel = itemModel.getModel('itemStyle.normal');\n    var front = el.childAt(0),\n        bottom = el.childAt(1),\n        top = el.childAt(2),\n        text = el.childAt(3);\n\n    // front.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n    top.useStyle(zrUtil.defaults(\n        {\n            fill: leftColor(color, -0.2),\n            opacity: opacity\n        },\n        itemStyleModel.getBarItemStyle()\n    ));\n    bottom.useStyle(zrUtil.defaults(\n        {\n            fill: gradColor(color, isHorizontal),\n            opacity: opacity\n        },\n        itemStyleModel.getBarItemStyle()\n    ));\n\n    // 正面的矩形需要时颜色渐变才能看出圆柱体效果\n    front.useStyle(zrUtil.defaults(\n        {\n            fill: gradColor(color, isHorizontal),\n            opacity: (opacity - 0.2) > 0 ? (opacity - 0.2) : 0.1\n        },\n        itemStyleModel.getBarItemStyle()\n    ));\n\n    text.useStyle(zrUtil.defaults(\n        {\n            fill: 'rgba(0,0,0,0)'\n        }\n    ));\n\n    var labelPositionOutside = isHorizontal\n        ? (layout.height > 0 ? 'bottom' : 'top')\n        : (layout.width > 0 ? 'left' : 'right');\n\n    helper.setLabel(\n        text.style, hoverStyle, itemModel, color,\n        seriesModel, dataIndex, labelPositionOutside\n    );\n\n    helper.setHoverStyle(el, hoverStyle);\n}\n\n\n/**\n * 获取圆柱体正面\n * @param {Object} shape \n * @param {Boolean} isHorizontal \n */\nfunction getCylinderFront(shape, isHorizontal) {\n    /*return isHorizontal ? {\n        x: shape.x ,\n        y: shape.y - shape.width / 8,\n        width: shape.width,\n        height: shape.height + shape.width / 8\n    } : {\n            x: shape.x + shape.height / 8,\n            y: shape.y,\n            width: shape.width - shape.height / 8,\n            height: shape.height\n        }*/\n    return isHorizontal ? {\n        x: shape.x,\n        y: shape.y - shape.width / 8,\n        width: shape.width,\n        height: shape.height\n    } : {\n            x: shape.x + shape.height / 8,\n            y: shape.y,\n            width: shape.width,\n            height: shape.height\n        }\n}\n\n/**\n * 获取圆柱体正面\n * @param {Object} shape \n * @param {Boolean} isHorizontal \n */\nfunction getCylinderTop(shape, isHorizontal) {\n    /*return isHorizontal ? {\n        cx: shape.x + shape.width / 2,\n        cy: shape.y + shape.height,\n        rx: shape.width / 2,\n        ry: shape.width / 8,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            cx: shape.x + shape.width,\n            cy: shape.y + shape.height / 2,\n            rx: shape.height / 8,\n            ry: shape.height / 2,\n            sw: shape.width,\n            sh: shape.height\n        }*/\n    return isHorizontal ? {\n        cx: shape.x + shape.width / 2,\n        cy: shape.y + shape.height - shape.width / 8,\n        rx: shape.width / 2,\n        ry: shape.width / 8,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            cx: shape.x + shape.width + shape.height / 8,\n            cy: shape.y + shape.height / 2,\n            rx: shape.height / 8,\n            ry: shape.height / 2,\n            sw: shape.width,\n            sh: shape.height\n        }\n}\n\n/**\n * 获取圆柱体底面\n * @param {Object} shape \n * @param {Boolean} isHorizontal \n */\nfunction getCylinderBottom(shape, isHorizontal) {\n    return isHorizontal ? {\n        cx: shape.x + shape.width / 2,\n        cy: shape.y - shape.width / 8,\n        rx: shape.width / 2,\n        ry: shape.width / 8,\n        sw: shape.width,\n        sh: shape.height\n    } : {\n            cx: shape.x + shape.height / 8,\n            cy: shape.y + shape.height / 2,\n            rx: shape.height / 8,\n            ry: shape.height / 2,\n            sw: shape.width,\n            sh: shape.height\n        }\n}\n\nfunction createCylinder(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var g = new graphic.Group();\n    g.isCube = false; // 设置是否立方体\n    var shape = zrUtil.extend({}, layout);\n\n    // 绘制正面\n    var front = new graphic.Rect({\n        location: 'front',\n        shape: getCylinderFront(shape, isHorizontal),\n        isHorizontal: isHorizontal\n    });\n\n    // 绘制文字图形容器\n    var text = new graphic.Rect({\n        location: 'text',\n        shape: getCylinderFront(shape, isHorizontal),\n        isHorizontal: isHorizontal\n    });\n\n    // 绘制底面\n    var bottom = new graph.Ellipse({\n        location: 'bottom',\n        shape: getCylinderBottom(shape, isHorizontal)\n    });\n\n    // 绘制顶面\n    var top = new graph.Ellipse({\n        location: 'top',\n        shape: getCylinderTop(shape, isHorizontal)\n    });\n\n    g.add(front);\n    g.add(bottom);\n    g.add(top);\n    g.add(text);\n\n    // Animation\n    if (animationModel) {\n        // 正面动画\n        var frontShape = front.shape;\n        var animateProperty = isHorizontal ? 'height' : 'width';\n        var animateTarget = {};\n        animateTarget[animateProperty] = frontShape[animateProperty];\n        frontShape[animateProperty] = 0;\n        graphic[isUpdate ? 'updateProps' : 'initProps'](front, {\n            shape: animateTarget\n        }, animationModel, dataIndex);\n        // 顶面动画\n        var topShape = top.shape;\n        var animateProperty = isHorizontal ? 'cy' : 'cx';\n        var animateTarget = {};\n        animateTarget[animateProperty] = topShape[animateProperty];\n        topShape[animateProperty] = bottom.shape[animateProperty];\n\n        graphic[isUpdate ? 'updateProps' : 'initProps'](top, {\n            shape: animateTarget\n        }, animationModel, dataIndex);\n    }\n\n    return g;\n}\n\n/**\n * 删除图形\n * @param {Number} dataIndex \n * @param {Object} animationModel \n * @param {Group} el \n */\nfunction removeRect(dataIndex, animationModel, el) {\n\n    // 运动的时候不显示文字\n    el.eachChild(function (childEl) {\n        childEl.style.text = '';\n    });\n\n    if (animationModel) {\n        var isCube = el.isCube;\n        isCube ? removeCube(dataIndex, animationModel, el) :\n            removeCylinder(dataIndex, animationModel, el);\n\n    } else {\n        graphic.updateProps(el, {\n            shape: {}\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n}\n\n/**\n* 删除立方体图形\n* @param {Number} dataIndex \n* @param {Object} animationModel \n* @param {Group} el \n* @param {Boolean} isHorizontal\n*/\nfunction removeCube(dataIndex, animationModel, el) {\n    var rightFlank = el.childAt(0),\n        bottom = el.childAt(1),\n        top = el.childAt(2),\n        front = el.childAt(3),\n        leftFlank = el.childAt(4);\n\n    var isHorizontal = front.isHorizontal;\n    var bshape = bottom.shape;\n\n    // 正面动画\n    graphic.updateProps(front, {\n        shape: isHorizontal ? {\n            height: 0\n        } : {\n                width: 0\n            }\n    }, animationModel, dataIndex, function () {\n        el.parent && el.parent.remove(el);\n    });\n\n    // 右侧面动画\n    graphic.updateProps(rightFlank, {\n        shape: isHorizontal ? {\n            height: 0\n        } : {\n                width: 0\n            }\n    }, animationModel, dataIndex);\n\n    // 左侧面动画\n    graphic.updateProps(leftFlank, {\n        shape: isHorizontal ? {\n            height: 0\n        } : {\n                width: 0\n            }\n    }, animationModel, dataIndex);\n\n    // 顶面动画\n    graphic.updateProps(top, {\n        shape: bshape\n    }, animationModel, dataIndex);\n}\n\n/**\n * 删除圆柱体图形\n * @param {Number} dataIndex \n * @param {Object} animationModel \n * @param {Group} el \n * @param {Boolean} isHorizontal\n */\nfunction removeCylinder(dataIndex, animationModel, el, isHorizontal) {\n\n    // 注位置要与存入一致\n    var front = el.childAt(0),\n        bottom = el.childAt(1),\n        top = el.childAt(2);\n\n    var isHorizontal = front.isHorizontal;\n    var bShape = bottom.shape;\n\n    graphic.updateProps(front, {\n        shape: isHorizontal ? {\n            height: 0\n        } : {\n                width: 0\n            }\n    }, animationModel, dataIndex, function () {\n        el.parent && el.parent.remove(el);\n    });\n\n    graphic.updateProps(top, {\n        shape: bShape\n    }, animationModel, dataIndex, function () {\n\n    });\n}\n\n/**\n * 获取柱状图柱子布局大小\n * @param {} data \n * @param {Number} dataIndex \n * @param {Model} itemModel \n */\nfunction getRectItemLayout(data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout);\n\n    // fix layout with lineWidth\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n\n    return {\n        x: layout.x + signX * fixedLineWidth / 2,\n        y: layout.y + signY * fixedLineWidth / 2,\n        width: layout.width - signX * fixedLineWidth,\n        height: layout.height - signY * fixedLineWidth,\n        length: itemModel.get('barLength')\n    };\n}\n\n// In case width or height are too small.\nfunction getLineWidth(itemModel, rawLayout) {\n    var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n    return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = BarView;\n\n//# sourceURL=webpack://echarts-bar3d/./src/bar3d/Bar3dView.js?");

/***/ }),

/***/ "./src/bar3d/bar3dLayout.js":
/*!**********************************!*\
  !*** ./src/bar3d/bar3dLayout.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(/*! echarts/lib/echarts */ \"echarts/lib/echarts\");\n\n/**\n * 绘制4边形\n */\nvar Quadrangle = echarts.graphic.extendShape({\n    type: 'quadrangle',\n    shape: {\n        points: [],\n        width: 0,\n        height: 0\n    },\n    buildPath: function (ctx, shape) {\n        var points = [[shape.x, shape.y],[shape.x1, shape.y1]];\n        var w = shape.width, h = shape.height;\n\n        // 根据width/height获取另外两个点便于动画\n        points[2] = [points[1][0] + w, points[1][1] + h];\n        points[3] = [points[0][0] + w, points[0][1] + h];\n\n        ctx.moveTo.apply(ctx, points[0]);\n        ctx.lineTo.apply(ctx, points[1]);\n        ctx.lineTo.apply(ctx, points[2]);\n        ctx.lineTo.apply(ctx, points[3]);\n        ctx.closePath();\n    }\n});\n\nvar Ellipse = echarts.graphic.extendShape({\n    type: 'ellipse',\n\n    shape: {\n        cx: 0, cy: 0,\n        rx: 0, ry: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var k = 0.5522848;\n        var x = shape.cx;\n        var y = shape.cy;\n        var a = shape.rx;\n        var b = shape.ry;\n        var ox = a * k; // 水平控制点偏移量\n        var oy = b * k; // 垂直控制点偏移量\n        // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\n        ctx.moveTo(x - a, y);\n        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\n        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\n        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\n        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\n        ctx.closePath();\n    }\n});\n\nmodule.exports = {\n    Quadrangle: Quadrangle,\n    Ellipse: Ellipse\n}\n\n//# sourceURL=webpack://echarts-bar3d/./src/bar3d/bar3dLayout.js?");

/***/ }),

/***/ "./src/bar3d/barItemStyle.js":
/*!***********************************!*\
  !*** ./src/bar3d/barItemStyle.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var makeStyleMapper = __webpack_require__(/*! echarts/lib/model/mixin/makeStyleMapper */ \"./node_modules/echarts/lib/model/mixin/makeStyleMapper.js\");\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n    getBarItemStyle: function (excludes) {\n        var style = getBarItemStyle(this, excludes);\n\n        if (this.getBorderLineDash) {\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n        }\n\n        return style;\n    }\n};\nmodule.exports = _default;\n\n//# sourceURL=webpack://echarts-bar3d/./src/bar3d/barItemStyle.js?");

/***/ }),

/***/ "./src/bar3d/helper.js":
/*!*****************************!*\
  !*** ./src/bar3d/helper.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(/*! echarts/lib/echarts */ \"echarts/lib/echarts\");\nvar helper = {};\nvar graphic = echarts.graphic;\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nhelper.setLabel = setLabel;\n\n\nhelper.setHoverStyle = function (el, hoverStyle) {\n    var temp = echarts.util.clone(hoverStyle);\n    // 监听group事件\n    graphic.setHoverStyle(el, {});\n    var isCube = el.isCube;\n    el.eachChild(function (child) {\n        if (child.location != 'front' && child.location != 'text') {\n            graphic.setHoverStyle(child, echarts.util.extend(temp, { text: '' }));\n        } else if (child.location == 'front' && !isCube) {\n            graphic.setHoverStyle(child, echarts.util.extend(temp, { text: '' }));\n        } else if (child.location == 'front' && isCube) {\n            graphic.setHoverStyle(child, hoverStyle);\n        } else if (child.location == 'text') {\n            graphic.setHoverStyle(child, child.style);\n        }\n        child.off('mouseover').off('mouseout').off('emphasis').off('normal');\n    });\n}\n\nmodule.exports = helper;\n\n//# sourceURL=webpack://echarts-bar3d/./src/bar3d/helper.js?");

/***/ }),

/***/ "echarts/lib/echarts":
/*!**************************!*\
  !*** external "echarts" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__;\n\n//# sourceURL=webpack://echarts-bar3d/external_%22echarts%22?");

/***/ })

/******/ });
});